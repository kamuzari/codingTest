목차

[1.카드 짝 맞추기](#1카드-짝-맟추기) <br>
[2.모두 0으로 만들기](#2모두-0으로-만들기) <br>
[3.스킬 트리](#3스킬-트리) <br>



## 1.카드 짝 맞추기

---
**핵심 : 모든 카드의 짝을 맞추어 제거할 수 있는 최소 경로의 수.**

1. 주어진 board 2차원 배열에 나올 수 있는 카드 번호들을 가지고 나올수 있는 경우의 수를 모두 뽑는다.
2. 각 주어진 순서대로 카드를 탐색하는 최소 경로의 수를 탐색한다.
    * 단 Enter 키 또한 움직이는 최소 거리에 포함시킨다.
3. 나올 수 있는 경우의 수들중 최소 탐색 횟수를 출력.

### experienced problem :
- board 의 2차원 배열 값에는 카드번호가 1-6번까지 주어지는데 1~6 번 랜덤한 값이 들어올 수 있을므로 해당 값을 저장할 링크드 리스트를 사용
- 순열 탐색으로 각 경우의 수를 추출할 때 get({$index}) 하는 부분에서 탐색시 시간 초과가 발생.
- 탐색의 효율성은 ArrayList가 더 좋다 단, 삽입,삭제가 빈번하지 않을 때.

## 2.모두 0으로 만들기

---
**핵심 : 가중치의 합을 0으로 만들기 위해 음수 ,양수 값을 고려하여 최소 연산의 횟수를 구한다.**

1. 진입 차수가 없는 노드를 기점으로 탐색을 진행한다.
    - 위상 정렬을 이용하여 진입 차수가 1인 지점을 EnQueue한다.
2. 말단 노드부터 시작하므로 다음으로 이어질 정점의 상태에 대한 상태 배열을 설정한다.
    - 왜냐하면 모두 0으로 만드는 횟수를 구하기 때문에 각 정점을 도달했을 때의 상태를 넣어줘야 한다.
    -  \#1/+2  - > \#2/-2 라는 점에서 두 연산의 횟수는 2번이다. (한쪽에는 -1을 하고 다른 한 쪽에는 +1을 한다.)
    
### experienced problem :
- 1번 노드에 도달했을 때 결과값에 절댓값 +2 를하고 다음 #2번 노드를 enqueue한다. 그다음 #2번노드가 poll() 할 떄 해당 값을 +2을 절댓값으로 더 더해 버린다면 결과 값에는 +4가 나오게 된다.
- 총 가중치의 합이 아닌 연산의 0으로 만들기 위한 연산의 횟수이므로 정점을 도달했을 때의 가중치의 합의 상태를 나타내는 배열이 필요하다.


## 3.스킬 트리
**핵심: 주어진 스킬 트리의 순서**
ABD : A -> B -> D 거스를 수 없고 또한 B없이 D가 출연해서는 안된다.

### experienced problem :
- 위 핵심에서 B없이 D가 출연해서는 안된다.라는 사실을 인지 못하고 처리했다.
   - 이전 인덱스에서 출연하는 여부 또는 우선순위큐로 각 스킬 트리만 우선순위에 넣어서 꺼낼 때 비교 조건을 처리하기가 복잡했고 코드가 많이 난해해졌다.
- 그래서  indexOf 로 해당 인덱스의 시작위치 0이 반환되는 조건을 발견함.
   - ex )  BCD 인데 BC만 나오는 경우 또한 0이된다 그리고 BD는 스킬트리에 맞지않는 조건이므로 이부분도 손쉽게 제외할 수 있다.